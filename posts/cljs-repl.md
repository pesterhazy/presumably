---
title: "What the F!GWH33L is a ClojureScript REPL?"
uuid: ec39917b-6828-4373-8552-380aba85a570
author: Paulus
date-published: 2019-01-11
---

Onboarding new developers to ClojureScript teams is a joy, mostly. You get to talk about all the things that make it fun to write web apps in a Lisp. But when we get to the topic of REPLs - arguably the most LISP-y of topics - there's often an awkard pause. While ClojureScript REPLs are well-supported these days, it's far from obvious how they work - and how to get them to work.

In this post, my goal is to explain CLJS repls in a way that I would have liked someone to explain them to me when I was starting out. But most pressing question on the newcomer's mind is how to set up. So while understanding the concepts is the goal, the path I'm taking in the post will be a guid to setting up a working REPL using figwheel main. 

## Getting started

```
clojure -Sdeps '{:deps {seancorfield/clj-new {:mvn/version "0.8.4"}}}' -m clj-new.create figwheel-main playground.core -- --reagent

# Generating fresh figwheel-main project.
#    -->  To get started: Change into the 'playground.core' directory and run 'clojure -A:fig:build'
```

Well, that was easy enough!

```
mv playground.core playground # Strange name for a directory
cd playground
```

Let's do some chores

```
$ git init
Initialized empty Git repository in /Users/pe/prg/playground/.git/
$ git add .
$ git commit -m "Init"
$ tree
.
├── README.md
├── deps.edn
├── dev.cljs.edn
├── figwheel-main.edn
├── resources
│   └── public
│       ├── css
│       │   └── style.css
│       ├── index.html
│       └── test.html
├── src
│   └── playground
│       └── core.cljs
├── target
│   └── public
├── test
│   └── playground
│       ├── core_test.cljs
│       └── test_runner.cljs
└── test.cljs.edn
```

As the autogenerated README tells us, we can now start a development enviroment as follows:

```
$ clojure -A:fig:build
** SNIP **
Opening URL http://localhost:9500
ClojureScript 1.10.520
cljs.user=>
```

After the "Opening URL http://localhost:9500" line, Figwheel will attempt to start a browser pointed at the local URL, which make take a few seconds. If this step fails, you can open the URL manually in a browser of you choice (Chrome, Firefox and Safari should all work). Although it's possible to open the URL in multiple browsers or tabs at once, at the beginning it's best to make sure only one tab opening the URL is open at the same time.

Now Figwheel gives you two cool ways of getting changes into your browsers. The first way is to change the source file and to save it. You could open src/playground/core.cljs in your favoire editor and change the hello-world. Or you could do it in an unnecessarily complicated way:

```
$ cat > rocks.patch
diff --git a/src/playground/core.cljs b/src/playground/core.cljs
index 237b5a9..ff8143f 100644
--- a/src/playground/core.cljs
+++ b/src/playground/core.cljs
@@ -10,21 +10,21 @@

 ;; define your app data so that it doesn't get over-written on reload
 (defonce app-state (atom {:text "Hello world!"}))

 (defn get-app-element []
   (gdom/getElement "app"))

 (defn hello-world []
   [:div
    [:h1 (:text @app-state)]
-   [:h3 "Edit this in src/playground/core.cljs and watch it change!"]])
+   [:h3 "Live reload rocks"]])

 (defn mount [el]
   (reagent/render-component [hello-world] el))

 (defn mount-app-element []
   (when-let [el (get-app-element)]
     (mount el)))

 ;; conditionally start your application based on the presence of an "app" element
 ;; this is particularly helpful for testing this ns without launching the app
```

And now apply the patch

```
$ patch -p1 < rocks.patch
patching file src/playground/core.cljs
```

You should see the string "Live reload rocks" appear on your screen. When you reload your browser, you will also see the new string.

But while saving waiting for your namespace to reload is useful, it is not the only way to update your browser window. There's also REPL evaluation.

When you see `cljs.user=>`, you can start typing Clojure forms into the prompt. Try this and watch the background color of the page change:

```
cljs.user=> (set! (.-backgroundColor (.-style (js/document.querySelector "body"))) "#decade")
"#decade"
```

From the prompt you can also interact with the code in your application. The following form will update what you see in your browser window:

```
cljs.user=> (swap! playground.core/app-state update :text clojure.string/upper-case)
{:text "HELLO WORLD!"}
```
