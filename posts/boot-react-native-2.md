---
title: "Getting started with Boot React Native (2)"
subtitle: "Part 2"
author: Paulus
# date-published: 2016-07-31
---

React Native apps in ClojureScript is fun. As I explained in part 1 of this
series, Boot React Native is a tool to work on code with real-time core
reloading, providing us with a short feedback loop.

With the setup out of the way, I will explain how buildling native apps in
ClojureScript works in practice. In the web of tooling, Boot React Native has
the job of getting cljs code into your app, in the simulator or on a physical
device.

During development mode (`boot dev`), this process has two steps. First, BRN
takes the `.js` files generated by the ClojureScript compiler and makes them
available in the `app/build/node_modules` directory. Next, by injecting
JavaScript code, it intercepts calls to `goog.require` and redirects them to the
`require` function provided by the React Native runtime. As ClojureScript
modules end up in `node_modules`, the packager finds them, so that
`goog.require('mattsum.simple_example.core')` correcly loads the
"mattsum.simple_example.core" namespace.

In this initial step, all the code is bundled into a single `.js` file. To make
subsequent changes faster, Boot React Native uses a different method to inject
code changes into the running system. Once one or more files are changed, Boot
Reload kicks in and sends the changed `.js` files over a websocket connection to
the running app through a *reload bridge*. When the bridge has loaded the code,
it triggers the
[`on-js-reload` hook](https://github.com/mjmeintjes/boot-react-native/blob/de752982cfc850f80c67ee472b3891b404844221/example/src/mattsum/simple_example/core.cljs#L51)
in your code. This hook should make sure that all changes to the UI are
reflected in the app, while retaining any application state previously built up. 

### Changing the UI

To make changes to the code, you

### Adding images

### Coping with errors

### Debugging using Chrome Debugger

### Using the REPL
